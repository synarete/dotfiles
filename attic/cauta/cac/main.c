/*
 * CaC: Cauta-to-C Compiler
 *
 * Copyright (C) 2016,2017,2018 Shachar Sharon
 *
 * CaC is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * CaC is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with CaC. If not, see <https://www.gnu.org/licenses/gpl>.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#include "config-site.h"
#endif

#ifndef _GNU_SOURCE
#define _GNU_SOURCE 1
#endif

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <locale.h>
#include <unistd.h>
#include <getopt.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "macros.h"
#include "infra.h"
#include "lexer.h"
#include "parser.h"

/* Inspect C-compiler type (GCC|Clang) */
#undef CAC_GCC
#undef CAC_CLANG
#undef CAC_ICC

#if defined(__GNUC__)
#define CAC_GCC     1
#endif
#if defined(__clang__)
#define CAC_CLANG   2
#undef CAC_GCC
#endif
#if defined(__INTEL_COMPILER)
#define CAC_ICC     3
#error "ICC -- Untested"
#endif
#if !defined(CAC_GCC) && !defined(CAC_CLANG)
#error "Unknown compiler"
#endif
#if defined(CAC_GCC) && defined(CAC_CLANG)
#error "Compilers conflict"
#endif


/* Require C-compiler capabilities */
#if !defined(__SIZEOF_INT128__)
#error "No __SIZEOF_INT128__"
#endif

#if !defined(CAC_CLANG)
#if !defined(__SIZEOF_FLOAT128__)
#error "No __SIZEOF_FLOAT128__"
#endif
#endif

/* Version string */
#if defined(VERSION) && defined(RELEASE) && defined(REVISION)
static const char *const g_version = VERSION "-" RELEASE "." REVISION;
#elif defined(CAC_VERSION)
static const char *const g_version = MAKESTR(CAC_VERSION);
#else
static const char *const g_version = "0.0.0";
#endif

/* Build time-stamp */
#if defined(CAC_BUILDDATE)
static const char *const g_timestamp = MAKESTR(CAC_BUILDDATE);
#else
static const char *const g_timestamp = __DATE__ " " __TIME__;
#endif


/* Program's global arguments & options */
typedef struct progargs {
	int     argc;
	char  **argv;       /* Command-line arguments */
	char   *prog;       /* Program's name */
	char   *main;       /* Main code entry */
	int     verbose;    /* Run in verbose mode */
	int     check_only; /* Check only mode */
	char   *output;     /* Output file-name (optional) */
	char   *input;      /* Input source */

} progargs_t;


/* Program's arguments */
static int g_exitcode;
static int g_argc;
static char **g_argv;
static progargs_t g_args;

/* Local functions forward declarations */
static void init_globals(int argc, char *argv[]);
static void parse_progargs(void);
static void execute_compiler(void);
static void fini_globals(void);
static void exit_program(void);


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                           *
 *                                                                           *
 *                             Cauta-to-C Compiler                           *
 *                                                                           *
 *                                                                           *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
int main(int argc, char *argv[])
{
	/* Begin with defaults */
	init_globals(argc, argv);

	/* Parse command-line args */
	parse_progargs();

	/* Execute front-end */
	execute_compiler();

	/* Cleanups */
	fini_globals();

	/* Goodbye :) */
	exit_program();

	return 0;
}

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

static void exit_program(void)
{
	if (g_exitcode == 0) {
		exit(EXIT_SUCCESS);
	} else {
		exit(EXIT_FAILURE);
	}
}

static void print_progname_hook(void)
{
	fprintf(stderr, "%s: ", program_invocation_short_name);
}

static void init_globals(int argc, char *argv[])
{
	g_exitcode = 0;
	g_argc = argc;
	g_argv = argv;
	umask(077);
	setlocale(LC_ALL, "");
	gc_init();

	error_print_progname = print_progname_hook;
}

static void fini_globals(void)
{
	memset(&g_args, 0, sizeof(g_args));
	gc_fini();
}

static void print_output(const context_t *ctx)
{
	FILE *fp = stdout;
	const char *pathname = g_args.output;

	if (pathname != NULL) {
		fp = fopen(pathname, "w+");
		if (fp == NULL) {
			fatal_error("unable to fopen '%s'", pathname);
		}
	}
	fprintf(fp, "/* Generated by cac %s */\n", g_version);
	fprintf(fp, "%s\n\n", ctx->output->str);
	if (g_args.main != NULL) {
		fputs("int main(void) \n", fp);
		fputs("{ \n", fp);
		fprintf(fp, "\tconst char *vers = \"%s\";\n", g_version);
		fprintf(fp, "\tconst char *mtag = \"%s\";\n", g_args.main);
		fputs("\tprintf(\"%s\\n\", vers);", fp);
		fputs("\tprintf(\"%s\\n\", mtag);", fp);
		fputs("\n", fp);
		fputs("\treturn 0; \n", fp);
		fputs("} \n\n", fp);
	}
	fflush(fp);
	if (fp != stdout) {
		fclose(fp);
	}
}

static void execute_compiler(void)
{
	context_t *ctx;
	ast_root_t *ast;

	ctx = new_context();
	if (g_args.input) {
		ast = parse_input(ctx, string_new(g_args.input));
	}
	if (!g_args.check_only) {
		print_output(ctx);
	}
	ctx = NULL;
	ast = NULL;

	(void)ast;
}

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

static void show_version(void)
{
	printf("%s %s %s\n", g_args.prog, g_version, g_timestamp);
}

static void show_vinfo(void)
{
	printf("program: %s \n", g_args.prog);
	printf("version: %s \n", g_version);
	printf("timestamp: %s \n", g_timestamp);
#ifdef CAC_CONFIG_SITE
	printf("prefix: %s\n", CAC_PREFIX);
	printf("bindir: %s\n", CAC_BINDIR);
	printf("libdir: %s\n", CAC_LIBDIR);
	printf("sysconfdir: %s\n", CAC_SYSCONFDIR);
	printf("datadir: %s\n", CAC_DATAROOTDIR);
	printf("localstatedir: %s\n", CAC_LOCALSTATEDIR);
#endif
}


static void show_help(void)
{
	printf("usage: %s -o outfile infile\n\n", g_args.prog);
	printf("options: \n");
	printf("  -o, --output         Output file\n");
	printf("  -m, --main           Generate main code\n");
	printf("  -s, --check          Compile-check without output\n");
	printf("  -t, --bist           Run built-in self-test\n");
	printf("  -v, --version        Show version and exit\n");
}

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

static int isequal(const char *s1, const char *s2)
{
	return (s1 != NULL) && (s2 != NULL) && (strcmp(s1, s2) == 0);
}

static int isoption(const char *arg)
{
	return ((arg != NULL) && (strlen(arg) > 1) && (arg[0] == '-'));
}

static int
isoptarg(const char *arg, const char *opt_short, const char *opt_long)
{
	int res = 0;

	if (isoption(arg)) {
		if ((arg[0] == '-') && (arg[1] == '-')) {
			arg += 2;
			res = isequal(arg, opt_long);
		} else {
			arg += 1;
			res = isequal(arg, opt_short) || isequal(arg, opt_long);
		}
	}
	return res;
}

static char *require_arg(int pos, const char *name)
{
	const char *arg;

	if (pos >= g_args.argc) {
		fatal_error("missing argument for '%s'", name);
	}
	arg = g_args.argv[pos];
	if (isoption(arg)) {
		fatal_error("non-valid argument '%s' for '%s'", arg, name);
	}
	return gc_strdup(arg);
}

static void exit_success(void)
{
	exit(EXIT_SUCCESS);
}

static void parse_progargs(void)
{
	int pos = 1;
	const char *arg;

	g_args.prog = program_invocation_short_name;
	g_args.argc = g_argc;
	g_args.argv = g_argv;

	while (pos < g_args.argc) {
		arg = g_args.argv[pos];
		if (!isoption(arg)) {
			break;
		}
		pos += 1;
		if (isoptarg(arg, "h", "help")) {
			show_help();
			exit_success();
		} else if (isoptarg(arg, NULL, "version")) {
			show_version();
			exit_success();
		} else if (isoptarg(arg, "v", NULL)) {
			show_vinfo();
			exit_success();
		} else if (isoptarg(arg, "V", "verbose")) {
			g_args.verbose = 1;
		} else if (isoptarg(arg, "s", "check")) {
			g_args.check_only = 1;
		} else if (isoptarg(arg, "m", "main")) {
			g_args.main = require_arg(pos, "--main");
			pos += 1;
		} else if (isoptarg(arg, "o", "output")) {
			g_args.output = require_arg(pos, "--output");
			pos += 1;
		} else {
			fatal_error("unknown option: %s", arg);
		}
	}
	if (g_args.main == NULL) {
		if (pos >= g_args.argc) {
			fatal_error("missing input");
		}
		arg = g_args.argv[pos++];
		g_args.input = gc_strdup(arg);
	}
	if (pos < g_args.argc) {
		fatal_error("redundant argument: %s", g_args.argv[pos]);
	}
}




