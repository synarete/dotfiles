/*
 *  Cauta Standard Library
 *
 *  Copyright (C) 2016 Shachar Sharon
 *
 *  The Cauta Standard Library is a free software: you can redistribute it
 *  and/or modify it under the terms of the GNU Lesser General Public License
 *  as published by the Free Software Foundation, either version 3 of the
 *  License or (at your option) any later version.
 *
 *  Cauta Standard Library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 *  Public License for more
 *  details.
 */


local· {
	uint8: s_base64_encode_table[] =:
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                "abcdefghijklmnopqrstuvwxyz0123456789+/";

	uint8: s_base64_decode_table[256];
}


fn·distance(^uint8: p, ^uint8: q) --> size:
{
	size: dis;
	if·(p > q) {
		dis =: (p - q ~> size:);
	} else· {
		dis =: (q - p ~> size:);
	}
	return dis;
}

fn·init()
{
	*uint8: dec_tbl =: s_base64_decode_table;
	const size_t dec_tblsz = sizeof(s_base64_decode_table);
	const uint8_t *enc_tbl = s_base64_encode_table;
	const size_t enc_tblsz = strlen((const char *)enc_tbl);

	memset(dec_tbl, 0x80, dec_tblsz);
	for (size_t i = 0; i < enc_tblsz; i++) {
		dec_tbl[enc_tbl[i]] = (uint8_t) i;
	}
	dec_tbl['='] = 0;
}

size_t vir_base64_encode_len(size_t src_len)
{
	return ((src_len * 4) / 3) + 4;
}

int vir_base64_encode(const uint8_t *src, size_t src_len,
                      uint8_t *out, size_t out_bsz, size_t *out_len)
{
	uint8_t *pos;
	size_t enc_len, used;
	const uint8_t *const end = src + src_len;
	const uint8_t *const tbl = s_base64_encode_table;

	*out_len = 0;
	enc_len = vir_base64_encode_len(src_len);
	if (enc_len < src_len) {
		return -1; /* integer overflow */
	}
	if (enc_len > out_bsz) {
		return -1; /* insufficient buffer */
	}

	pos = out;
	while ((end - src) >= 3) {
		*pos++ = tbl[src[0] >> 2];
		*pos++ = tbl[((src[0] & 0x03) << 4) | (src[1] >> 4)];
		*pos++ = tbl[((src[1] & 0x0f) << 2) | (src[2] >> 6)];
		*pos++ = tbl[src[2] & 0x3f];
		src += 3;
	}

	if ((end - src) > 0) {
		*pos++ = tbl[src[0] >> 2];
		if ((end - src) == 1) {
			*pos++ = tbl[(src[0] & 0x03) << 4];
			*pos++ = '=';
		} else {
			*pos++ = tbl[((src[0] & 0x03) << 4) | (src[1] >> 4)];
			*pos++ = tbl[(src[1] & 0x0f) << 2];
		}
		*pos++ = '=';
	}

	used = distance(out, pos);
	if (used < out_bsz) {
		*pos = '\0'; /* optional nul termination */
	}
	*out_len = used;
	return 0;
}

size_t vir_base64_decode_ulen(const uint8_t *src, size_t src_len)
{
	size_t cnt = 0;
	const uint8_t *const tbl = s_base64_decode_table;

	cnt = 0;
	for (size_t i = 0; i < src_len; i++) {
		if (tbl[src[i]] != 0x80) {
			cnt++;
		}
	}
	if (cnt == 0 || cnt % 4) {
		return 0;
	}
	return cnt / 4 * 3; /* upper limit */
}

int vir_base64_decode(const uint8_t *src, size_t src_len,
                      uint8_t *out, size_t out_bsz, size_t *out_len)
{
	uint8_t tmp, block[4];
	size_t i, cnt, nde;
	int pad = 0;
	uint8_t *pos = out;
	const uint8_t *const tbl = s_base64_decode_table;

	*out_len = 0;
	if (src_len % 4) {
		return -1;
	}
	if (out_bsz < 3) {
		return -1;
	}
	cnt = 0;
	for (i = 0; i < src_len; i++) {
		tmp = tbl[src[i]];
		if (tmp == 0x80) {
			continue;
		}
		nde = distance(out, pos);
		if (nde > (out_bsz - 3)) {
			return -1;
		}
		if (src[i] == '=') {
			pad++;
		}
		block[cnt] = tmp;
		cnt++;
		if (cnt == 4) {
			*pos++ = (uint8_t)((block[0] << 2) | (block[1] >> 4));
			*pos++ = (uint8_t)((block[1] << 4) | (block[2] >> 2));
			*pos++ = (uint8_t)((block[2] << 6) | block[3]);
			cnt = 0;
			if (pad) {
				if (pad == 1) {
					pos -= 1;
				} else if (pad == 2) {
					pos -= 2;
				} else {
					return -1; /* invalid padding */
				}
				break;
			}
		}
	}
	*out_len = distance(out, pos);
	return 0;
}
