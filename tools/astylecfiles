#!/usr/bin/env python3
#
# astylecfiles.py -- Wrapper over 'astyle' utility
#
# Copyright (C) 2017 Synarete
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#

import sys
import os
import stat
import shlex
import subprocess
import distutils.spawn

ASTYLE_CONFIG = \
    '''
    -n -W
    --style=1tbs
    --indent=tab=4
    --convert-tabs
    --align-pointer=name
    --pad-oper
    --pad-header
    --unpad-paren
    --min-conditional-indent=0
    --indent-preprocessor
    --add-brackets
    --break-after-logical
    --max-code-length=80
    --indent-col1-comments
    --indent-switches
    --lineend=linux
  '''


def msg(txt: str) -> None:
    name = os.path.basename(__file__)
    print(name + ': ' + txt)


def die(txt: str) -> None:
    msg(txt)
    sys.exit(-1)


def getext(path: str) -> str:
    return str(os.path.splitext(path)[1])


def iscfile(path: str) -> bool:
    return getext(path) == '.c'


def ishfile(path: str) -> bool:
    return getext(path) == '.h'


def isreg(path: str) -> bool:
    try:
        return stat.S_ISREG(os.stat(path).st_mode)
    except (NameError, OSError):
        return False


def issource(path: str) -> bool:
    return isreg(path) and (iscfile(path) or ishfile(path))


def locate_astyle():
    astylebin = distutils.spawn.find_executable('astyle')
    if not astylebin:
        die('failed to find astyle')
    return str(astylebin).strip()


def subexec(cmd, wd=None) -> str:
    '''Execute command as sub-process, die upon failure'''
    pipes = subprocess.Popen(shlex.split(cmd),
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE,
                             cwd=wd,
                             shell=False,
                             env=os.environ.copy())
    std_out, std_err = pipes.communicate()
    if len(std_err) > 0:
        out = std_err
    else:
        out = std_out
    if pipes.returncode != 0:
        die('failed: ' + cmd)
    return out.decode('UTF-8')


def astylecfiles(files: list) -> None:
    '''Run astyle tool on input C files'''
    astyle = locate_astyle()
    astyle_args = ' '.join(ASTYLE_CONFIG.split())
    for src in [f for f in files if issource(f)]:
        cmd = astyle + ' ' + astyle_args + ' ' + src
        res = subexec(cmd)
        if 'Unchanged' not in res:
            msg(str(res).strip())


def listfiles(path: str) -> list:
    '''Recursive listing for C source/header files'''
    files = []
    for ff in os.listdir(path):
        if str(ff) == '.' or str(ff) == '..':
            continue
        pf = os.path.abspath(os.path.join(path, ff))
        if os.path.isdir(pf):
            files = files + listfiles(pf)
        else:
            files.append(pf)
    return files


def resolvesources(sources: list) -> list:
    files = []
    if len(sources) == 0:
        files = listfiles(os.getcwd())
    else:
        for src in sources:
            if os.path.isdir(src):
                files = files + listfiles(src)
            else:
                files.append(src)
    return list(set(files))


def settitle(title: str) -> None:
    try:
        import setproctitle
        setproctitle.setproctitle(title)
    except ImportError:
        pass


def main() -> None:
    settitle(os.path.basename(sys.argv[0]))
    astylecfiles(resolvesources(sys.argv[1:]))


if __name__ == '__main__':
    main()
